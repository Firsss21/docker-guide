## Docker quick guide

### Что такое Docker?

Docker - платформа контейнеризации, с помощью которой можно автоматизировать создание приложений, их доставку и управление.

+ Контейнер - способ упаковки приложения со всеми необходимыми зависимостями и конфигурациями, которым можно легко "обмениваться"

+ До контейнеров - нужно было все устанавливать на систему и каждый все нужно было настраивать в зависимости от OS.

+ С контейнерами - все становится изолированно

+ Контейнер состоит из нескольких "слоев"

+ В большинстве своем контейнеры `Linux based`, а также используют `alpine` версию для минимального размера

### Разница между Docker Image и Docker Container

+ Docker Image - образ, который мы запускаем со всеми настройками
	
+ Docker Container - запущенный образ, запускаемое окружение для образа, уже для него делается `port binding`, виртуальная файловая система

### Сравнение Docker и VM

Docker в сравнении с вирутальными машинами проще для разработки, для разворачивания, а также имеется репозиторий контейнеров

#### Рассмотрим работу Docker и VM на уровне ОС. 

+ Основные уровни  ОС Linux состоят из:  1. Applications, 2. OS Kernel, 3. Hardware

+ Docker работает на прикладном уровне, работают не на OS Kernel, а на уровне application.

+ VM - работает как на OS Kernel так и на application, полноценная операционная система, в отличии от Docker

+ Docker - занимает меньше, запускаются быстрее, 

+ VM - запускается на любой ОС, тк он сам в себе содержит ядро

### Описание команд Docker

`docker pull {image}:{tag}` - скачивает необходимую версию образа

`docker run (-d запуск в автономном режиме) {id} (--name {name} имя для контейнера -p {from:to} проброс портов -e {name}={value} переменные --net {name} выбранная сеть -m {size} размер памяти) -v {name} подключение volume` - создание нового контейнера из образа

`docker start {id} (-a подключится к выводу)` -  запускает имеющийся контейнер **(не образ!)**
 
`docker stop {id}` - остановка имеющегося контейнера

`docker ps (-a включить незапущенные, -l только последний запущенный, -q вывод только id, -s размер контейнера)` - выводит список всех запущенных контейнеров

`docker logs {id} (-f ожидает вывод лога, -t вывод со временем, -n ограничение кол-ва строк)` - выводит логи контейнера

`docker exec -it  {container} /bin/bash` - подключится к контейнеру как к терминалу

`docker images` - показывает все ваши образы

`docker network ls` - выводит список сетей

`docker network create {name} (-d драйвер)` - создает новую сеть

`docker network create/disconnect {id}` - подключает/отключает контейнера от сети

`docker rmi {IMAGE} (-f принудительное удаление)` - удаляет образ

`docker rm {container} (-f принудительное удаление, -v вместе с volumes)` - удаляет контейнер

`docker rmi $(docker images -a -q)` - удаление всех образов

`docker rm $(docker ps -a -f status=exited -q)` - удаление всех выключенных контейнеров

`docker rmi $(docker images -a -q)` - удаление всех образов

`docker stop $(docker ps -a -q)` - остановка всех запущенных контейнеров

`docker rm $(docker ps -a -q)` - удаление всех контейнеров

### Container port и HOST port

Можно запускать несколько контейнеров на одном порту, но для этого нужно с хост-машины редиректить запросы через порт в нужный контейнер.
Например: 3 контейнера на 5000 порту, но с машины мы отправляем их с 5001 на 5000, 5002/5000, 5003/5000

### Docker network

Создает свою изолированную сеть, в которой контейнеры могут общаться по названию контейнера

### Docker Compose

`docker-compose up` - развёртывает сервисы веб-приложений и создаёт из docker-образа новые контейнеры, а также сети, тома и все конфигурации

`docker-compose down` -  останавливает все сервисы, связанные с определённой конфигурацией Docker Compose. В отличие от команды stop, она также удаляет все контейнеры и внутренние сети, связанные с этими сервисами

`docker-compose start` - запускает все остановленные сервисы в соответствии с параметрами остановленной конфигурации

`docker-compose stop` - останавливает все сервисы. Она НЕ удаляет ни контейнеры, ни связанные с ними внутренние тома и сети

### Docker volumes

Есть три разных вида *volume*

+ host volume:	*docker run -v {path host}:{path container}* - с определенным путем на хост-машине
+ anonymous volume: *docker run -v {path container}* - с неопределенным путем на хост-машине
+ name volume: *docker run -v {name}:{path container}* - только с определенным именем на хост машине (рекомендованный к использованию)

### Базовые пути данных "классических" баз данных

```yml
volumes: 
   - mongo-data:/data/db
   - mysql-data:/var/lib/mysql
   - postgresql-data:/var/lib/postgresql
```
### Подключение volume в файле конфигурации

```yml
volumes:
   mongo-data
      driver: local
```

### Базовый путь volumes в Docker

`/var/lib/docker/volumes`

### Docker tips
  
**1.** Используйте официальные образы, а не собирайте с нуля

**2.** Используйте теги. Не пульте всегда последнюю версию

+ Чтобы точно понимать, какую версия будет использоваться `(пр. nginx -> nginx:1.23)`

**3.** Чаще используйте alpine версию контейнера

+ Такие контейнеры содержат только **необходимые** компоненты для запуска контейнера, меньше весят, стабильнее работают `(пр. nginx -> nginx:alpine-1.23)`

**4.** Оптимизируйте кеширование слоев в dockerfile

+ Если один слой кеша не отвалился - последующие тоже отвалятся и будут заного создаваться.

+ <i>Ставьте слои, которые меняются толкьо в последнюю очередь<i>

*Пример:*
```yml
FROM node:alpine
WORKID /app
COPY myapp /app ---------------------- стоит поменять местами 
RUN npm install --production ---------
CMD ["node", "src/index.js"]
```
Если изменим файлы в директории `myapp`, то `RUN npm install` отвалится из кеша, поэтому меняем их местами

```yml
FROM node:alpine
WORKID /app
RUN npm install --production --------- поменяли
COPY myapp /app ----------------------
CMD ["node", "src/index.js"]
```
Теперь при копировании файлов из директории `/myapp` не будет инвалидироваться кеш `RUN npm install` и только один слой будет заного собран

**5.** Используйте `.dockerignore` файл для исключения ненужных файлов из контейнера

*Пример:*
```dockerignore
.git
.cache
*.md
```

**6.** Исключайте сборку в контейнере, используйте мультистейдж для создания контейнеров

+ В таком случае, в контейнере будет только необходимые файлы, без исходников

*Пример:*
```yml
#build stage
FROM maven as build
WORKDIR /app
COPY myapp /app
RUN mvn package

# Run stage
FROM tomcat
COPY --from=build /app/target/file.war /usr/local/tomcat/..
..etc
```
**7.** Используйте юзеров для использования контейнера.

+ Добавляйте юзера и группу для контейнеров, чтобы под рутом все не случайно поломали

*Пример:*
```yml
RUN groupadd -r tom && useradd -g tom tom
RUN chown -R tom:tom /app
USER tom
CMD node index.js
```
**8.**  Используйте `docker scan` для ваших контейнеров для проверки на уязвимости
